// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repo

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrder = `-- name: CreateOrder :one

INSERT INTO orders (order_number, customer_id, created_by, total_amount, status)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, order_number, customer_id, created_by, total_amount, status, created_at, updated_at
`

type CreateOrderParams struct {
	OrderNumber string      `json:"order_number"`
	CustomerID  pgtype.Int4 `json:"customer_id"`
	CreatedBy   pgtype.Int4 `json:"created_by"`
	TotalAmount pgtype.Int8 `json:"total_amount"`
	Status      pgtype.Text `json:"status"`
}

// Orders
func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.OrderNumber,
		arg.CustomerID,
		arg.CreatedBy,
		arg.TotalAmount,
		arg.Status,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.CreatedBy,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createOrderItem = `-- name: CreateOrderItem :one
INSERT INTO order_items (order_id, product_id, product_code, product_name, unit_price, quantity, line_total)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id
`

type CreateOrderItemParams struct {
	OrderID     pgtype.Int4 `json:"order_id"`
	ProductID   pgtype.Int4 `json:"product_id"`
	ProductCode pgtype.Text `json:"product_code"`
	ProductName pgtype.Text `json:"product_name"`
	UnitPrice   pgtype.Int8 `json:"unit_price"`
	Quantity    pgtype.Int4 `json:"quantity"`
	LineTotal   pgtype.Int8 `json:"line_total"`
}

func (q *Queries) CreateOrderItem(ctx context.Context, arg CreateOrderItemParams) (int32, error) {
	row := q.db.QueryRow(ctx, createOrderItem,
		arg.OrderID,
		arg.ProductID,
		arg.ProductCode,
		arg.ProductName,
		arg.UnitPrice,
		arg.Quantity,
		arg.LineTotal,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const createProduct = `-- name: CreateProduct :one

INSERT INTO products (product_id, product_name, supplier_name, category, price_idr, stock, created_by)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, product_id, product_name, supplier_name, category, price_idr, stock, created_by, created_at, updated_at
`

type CreateProductParams struct {
	ProductID    string      `json:"product_id"`
	ProductName  string      `json:"product_name"`
	SupplierName pgtype.Text `json:"supplier_name"`
	Category     pgtype.Text `json:"category"`
	PriceIdr     int64       `json:"price_idr"`
	Stock        int32       `json:"stock"`
	CreatedBy    pgtype.Int4 `json:"created_by"`
}

// Products
func (q *Queries) CreateProduct(ctx context.Context, arg CreateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, createProduct,
		arg.ProductID,
		arg.ProductName,
		arg.SupplierName,
		arg.Category,
		arg.PriceIdr,
		arg.Stock,
		arg.CreatedBy,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductName,
		&i.SupplierName,
		&i.Category,
		&i.PriceIdr,
		&i.Stock,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one


INSERT INTO users (user_id, username, email, full_name, password_hash, role)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, username, email, full_name, role, created_at, updated_at
`

type CreateUserParams struct {
	UserID       pgtype.Text `json:"user_id"`
	Username     string      `json:"username"`
	Email        string      `json:"email"`
	FullName     pgtype.Text `json:"full_name"`
	PasswordHash string      `json:"password_hash"`
	Role         string      `json:"role"`
}

type CreateUserRow struct {
	ID        int32              `json:"id"`
	UserID    pgtype.Text        `json:"user_id"`
	Username  string             `json:"username"`
	Email     string             `json:"email"`
	FullName  pgtype.Text        `json:"full_name"`
	Role      string             `json:"role"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

// internal/adapters/postgresql/sqlc/queries.sql
// Users
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.UserID,
		arg.Username,
		arg.Email,
		arg.FullName,
		arg.PasswordHash,
		arg.Role,
	)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT id, order_number, customer_id, created_by, total_amount, status, created_at, updated_at
FROM orders
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetOrderByID(ctx context.Context, id int32) (Order, error) {
	row := q.db.QueryRow(ctx, getOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.OrderNumber,
		&i.CustomerID,
		&i.CreatedBy,
		&i.TotalAmount,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProductByProductID = `-- name: GetProductByProductID :one
SELECT id, product_id, product_name, supplier_name, category, price_idr, stock, created_by, created_at, updated_at
FROM products
WHERE product_id = $1
LIMIT 1
`

func (q *Queries) GetProductByProductID(ctx context.Context, productID string) (Product, error) {
	row := q.db.QueryRow(ctx, getProductByProductID, productID)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductName,
		&i.SupplierName,
		&i.Category,
		&i.PriceIdr,
		&i.Stock,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, user_id, username, email, full_name, password_hash, role, created_at, updated_at
FROM users
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserByUsernameOrEmail = `-- name: GetUserByUsernameOrEmail :one
SELECT id, user_id, username, email, full_name, password_hash, role, created_at, updated_at
FROM users
WHERE username = $1 OR email = $2
LIMIT 1
`

type GetUserByUsernameOrEmailParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) GetUserByUsernameOrEmail(ctx context.Context, arg GetUserByUsernameOrEmailParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsernameOrEmail, arg.Username, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.PasswordHash,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOrders = `-- name: ListOrders :many
SELECT id, order_number, customer_id, created_by, total_amount, status, created_at, updated_at
FROM orders
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListOrdersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListOrders(ctx context.Context, arg ListOrdersParams) ([]Order, error) {
	rows, err := q.db.Query(ctx, listOrders, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i Order
		if err := rows.Scan(
			&i.ID,
			&i.OrderNumber,
			&i.CustomerID,
			&i.CreatedBy,
			&i.TotalAmount,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProducts = `-- name: ListProducts :many
SELECT id, product_id, product_name, supplier_name, category, price_idr, stock, created_by, created_at, updated_at
FROM products
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListProductsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListProducts(ctx context.Context, arg ListProductsParams) ([]Product, error) {
	rows, err := q.db.Query(ctx, listProducts, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Product
	for rows.Next() {
		var i Product
		if err := rows.Scan(
			&i.ID,
			&i.ProductID,
			&i.ProductName,
			&i.SupplierName,
			&i.Category,
			&i.PriceIdr,
			&i.Stock,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const nextProductSequence = `-- name: NextProductSequence :one

SELECT nextval('products_id_seq') as seq
`

// Utility queries
// This is a helper to get a next sequence number for product id generation if you prefer DB-side sequence.
func (q *Queries) NextProductSequence(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, nextProductSequence)
	var seq int64
	err := row.Scan(&seq)
	return seq, err
}

const updateProduct = `-- name: UpdateProduct :one
UPDATE products
SET product_name = COALESCE(NULLIF($2, ''), product_name),
    supplier_name = COALESCE(NULLIF($3, ''), supplier_name),
    category = COALESCE(NULLIF($4, ''), category),
    price_idr = COALESCE($5, price_idr),
    stock = COALESCE($6, stock),
    updated_at = now()
WHERE product_id = $1
RETURNING id, product_id, product_name, supplier_name, category, price_idr, stock, created_by, created_at, updated_at
`

type UpdateProductParams struct {
	ProductID string      `json:"product_id"`
	Column2   interface{} `json:"column_2"`
	Column3   interface{} `json:"column_3"`
	Column4   interface{} `json:"column_4"`
	PriceIdr  int64       `json:"price_idr"`
	Stock     int32       `json:"stock"`
}

func (q *Queries) UpdateProduct(ctx context.Context, arg UpdateProductParams) (Product, error) {
	row := q.db.QueryRow(ctx, updateProduct,
		arg.ProductID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.PriceIdr,
		arg.Stock,
	)
	var i Product
	err := row.Scan(
		&i.ID,
		&i.ProductID,
		&i.ProductName,
		&i.SupplierName,
		&i.Category,
		&i.PriceIdr,
		&i.Stock,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
SET username = COALESCE(NULLIF($2, ''), username),
    email = COALESCE(NULLIF($3, ''), email),
    full_name = COALESCE(NULLIF($4, ''), full_name),
    password_hash = COALESCE(NULLIF($5, ''), password_hash),
    updated_at = now()
WHERE id = $1
RETURNING id, user_id, username, email, full_name, role, created_at, updated_at
`

type UpdateUserParams struct {
	ID      int32       `json:"id"`
	Column2 interface{} `json:"column_2"`
	Column3 interface{} `json:"column_3"`
	Column4 interface{} `json:"column_4"`
	Column5 interface{} `json:"column_5"`
}

type UpdateUserRow struct {
	ID        int32              `json:"id"`
	UserID    pgtype.Text        `json:"user_id"`
	Username  string             `json:"username"`
	Email     string             `json:"email"`
	FullName  pgtype.Text        `json:"full_name"`
	Role      string             `json:"role"`
	CreatedAt pgtype.Timestamptz `json:"created_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (UpdateUserRow, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Column2,
		arg.Column3,
		arg.Column4,
		arg.Column5,
	)
	var i UpdateUserRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Username,
		&i.Email,
		&i.FullName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE users SET role = $1, updated_at = now() WHERE id = $2
`

type UpdateUserRoleParams struct {
	Role string `json:"role"`
	ID   int32  `json:"id"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.Role, arg.ID)
	return err
}
